{% extends 'base.html' %}
{% block content %}
<div class="row g-3">
  <div class="col-lg-6" id="live">
    <div class="section-card h-100">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h4>1. 라이브 녹화</h4>
        <span class="badge rounded-pill bg-primary">녹화 컨트롤</span>
      </div>
      <form method="post" action="{{ url_for('record_live_action') }}" class="mb-2" id="live-form">
        <label class="form-label" for="live_url">라이브 주소</label>
        <div class="input-group mb-2">
          <input name="live_url" id="live_url" type="url" class="form-control" placeholder="https://www.youtube.com/live/..." />
          <span class="input-group-text bg-light" id="live-timer" role="status" aria-live="polite">대기 중</span>
        </div>
        <div class="action-button-group d-flex flex-wrap gap-2" role="group">
          <button class="btn btn-outline-primary flex-fill" name="action" value="녹화 시작">녹화 시작</button>
          <button class="btn btn-outline-secondary flex-fill" name="action" value="일시정지">일시정지</button>
          <button class="btn btn-outline-danger flex-fill" name="action" value="종료" id="live-stop-button">종료</button>
          <button type="button" class="btn btn-outline-info flex-fill" id="live-search-button">검색</button>
          <button type="button" class="btn btn-outline-warning flex-fill" id="live-extend-button" disabled>녹화 시간 연장</button>
          <button type="button" class="btn btn-outline-dark flex-fill" id="live-capture-button">캡처</button>
        </div>
        <div class="d-flex justify-content-between align-items-center mt-2 small text-muted">
          <span id="live-auto-stop" class="fw-semibold">녹화 자동 종료 : 10:00</span>
          <span class="text-muted">일시정지 시 10분 동안 반응이 없으면 자동 종료</span>
        </div>
        <div class="form-text text-danger" id="live-status" aria-live="polite"></div>
      </form>
      <div class="live-preview mt-3" id="live-preview-wrapper">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <h6 class="mb-0">라이브 미리보기</h6>
          <span class="badge bg-light text-dark">YouTube</span>
        </div>
        <div class="ratio ratio-16x9 border rounded overflow-hidden bg-light" id="live-preview-shell">
          <iframe
            id="live-preview-frame"
            title="YouTube 라이브 미리보기"
            allowfullscreen
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            class="d-none"
          ></iframe>
          <div class="d-flex align-items-center justify-content-center h-100 text-muted" id="live-preview-placeholder">
            라이브 링크를 검색하면 스트리밍 화면이 나타납니다.
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="col-lg-6" id="download-box">
    <div class="section-card h-100">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h4>2. 링크 다운로드</h4>
        <span class="badge bg-light text-dark">진행률 표시</span>
      </div>
      <form id="download-form">
        <label class="form-label" for="video_url">다운로드할 링크</label>
        <div class="input-group mb-2">
          <input name="video_url" id="video_url" type="url" class="form-control" placeholder="https://www.youtube.com/..." required />
          <button class="btn btn-primary" type="submit">다운로드</button>
        </div>
        <div class="progress mb-2 d-none" id="download-progress">
          <div class="progress-bar" role="progressbar" style="width: 0%" id="download-progress-bar"></div>
        </div>
        <div class="small text-muted" id="download-status">대기 중</div>
      </form>
    </div>
  </div>

  <div class="col-lg-6" id="transcript">
    <div class="section-card h-100">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h4>3. 전사 및 요약</h4>
        <span class="badge bg-light text-dark">진행률 실시간 표시</span>
      </div>

      <form method="post" action="{{ url_for('transcript_action') }}" class="mb-4" id="transcript-form">
        <div class="d-flex justify-content-between mb-2">
          <h6 class="mb-0">전사</h6>
          <small class="text-muted">완료 시 설정한 디렉토리에 저장됩니다.</small>
        </div>
        <div class="row g-2 align-items-center">
          <div class="col-auto">
            <button type="button" class="btn btn-outline-secondary btn-sm" id="transcript-refresh">업데이트</button>
          </div>
          <div class="col-md-7">
            <select class="form-select" name="file_name" id="transcript-file">
              {% for cat in transcript_sources %}
              <optgroup label="{{ cat.name }}">
                {% if cat.files %}
                  {% for f in cat.files %}
                  <option>{{ f }}</option>
                  {% endfor %}
                {% else %}
                  <option disabled>파일이 없습니다</option>
                {% endif %}
              </optgroup>
              {% endfor %}
            </select>
          </div>
          <div class="col-md-4 d-grid">
            <button class="btn btn-primary">전사 시작</button>
          </div>
        </div>
        <div class="progress mt-2 d-none" id="transcript-progress">
          <div class="progress-bar bg-info" role="progressbar" style="width: 0%" id="transcript-progress-bar"></div>
        </div>
        <div class="form-text" id="transcript-status" aria-live="polite">대기 중</div>
      </form>

      <form method="post" action="{{ url_for('summary_action') }}" id="summary-form">
        <div class="d-flex justify-content-between mb-2">
          <h6 class="mb-0">요약</h6>
          <small class="text-muted">전사 파일을 바탕으로 요약본을 저장합니다.</small>
        </div>
        <div class="row g-2 align-items-center">
          <div class="col-auto">
            <button type="button" class="btn btn-outline-secondary btn-sm" id="summary-refresh">업데이트</button>
          </div>
          <div class="col-md-7">
            <select class="form-select" name="file_name" id="summary-file">
              {% for cat in summary_sources %}
              <optgroup label="{{ cat.name }}">
                {% if cat.files %}
                  {% for f in cat.files %}
                  <option>{{ f }}</option>
                  {% endfor %}
                {% else %}
                  <option disabled>파일이 없습니다</option>
                {% endif %}
              </optgroup>
              {% endfor %}
            </select>
          </div>
          <div class="col-md-4 d-grid">
            <button class="btn btn-success">요약 시작</button>
          </div>
        </div>
        <div class="progress mt-2 d-none" id="summary-progress">
          <div class="progress-bar bg-success" role="progressbar" style="width: 0%" id="summary-progress-bar"></div>
        </div>
        <div class="form-text" id="summary-status" aria-live="polite">대기 중</div>
      </form>
    </div>
  </div>
</div>

<div class="row g-3 mt-2" id="settings">
  <div class="col-12">
    <div class="section-card">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h4>4. 설정</h4>
        <span class="badge bg-info text-dark">경로 &amp; 인증서</span>
      </div>
      <form method="post" action="{{ url_for('settings_action') }}" class="row g-3">
        <div class="col-12">
          <h6 class="text-muted mb-2">녹화 · 다운로드 저장소</h6>
        </div>
        <div class="col-md-4">
          <label class="form-label">링크 다운로드 저장 위치</label>
          <input class="form-control" name="downloads" value="{{ settings.paths.downloads }}" />
        </div>
        <div class="col-md-4">
          <label class="form-label">라이브 녹화 저장</label>
          <input class="form-control" name="recordings" value="{{ settings.paths.recordings }}" />
        </div>
        <div class="col-md-4">
          <label class="form-label">캡처 저장 위치</label>
          <input class="form-control" name="captures" value="{{ settings.paths.captures }}" />
        </div>

        <div class="col-md-4">
          <label class="form-label">전사 저장 위치</label>
          <input class="form-control" name="transcripts" value="{{ settings.paths.transcripts }}" />
        </div>

        <div class="col-md-4">
          <label class="form-label">요약 저장 위치</label>
          <input class="form-control" name="summaries" value="{{ settings.paths.summaries }}" />
        </div>
        <div class="col-12">
          <h6 class="text-muted mb-2">Google Drive 경로</h6>
        </div>
        <div class="col-md-4">
          <label class="form-label">링크 다운로드 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="download_upload" id="download_upload" value="{{ settings.paths.download_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="download-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="download-upload-select" data-bind-input="download_upload"></select>
          <small class="text-muted">다운로드한 파일을 업로드할 기본 경로를 선택하세요.</small>
        </div>
        <div class="col-md-4">
          <label class="form-label">라이브 녹화 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="recording_upload" id="recording_upload" value="{{ settings.paths.recording_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="recording-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="recording-upload-select" data-bind-input="recording_upload"></select>
          <small class="text-muted">라이브 녹화 파일을 올릴 경로를 지정하세요.</small>
        </div>

        <div class="col-md-4">
          <label class="form-label">캡처 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="capture_upload" id="capture_upload" value="{{ settings.paths.capture_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="capture-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="capture-upload-select" data-bind-input="capture_upload"></select>
          <small class="text-muted">캡처 이미지 업로드 위치를 선택하세요.</small>
        </div>

        <div class="col-md-4">
          <label class="form-label">전사 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="transcript_upload" id="transcript_upload" value="{{ settings.paths.transcript_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="transcript-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="transcript-upload-select" data-bind-input="transcript_upload"></select>
          <small class="text-muted">rclone으로 연결된 Google Drive 폴더를 선택하세요.</small>
        </div>

        <div class="col-md-4">
          <label class="form-label">요약 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="summary_upload" id="summary_upload" value="{{ settings.paths.summary_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="summary-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="summary-upload-select" data-bind-input="summary_upload"></select>
          <small class="text-muted">폴더를 선택해 요약본 업로드 위치를 고를 수 있습니다.</small>
        </div>

        <div class="col-md-4">
          <label class="form-label">일반 업로드 경로</label>
          <div class="input-group mb-1">
            <input class="form-control gdrive-path-input" name="gdrive_upload" id="gdrive_upload" value="{{ settings.paths.gdrive_upload }}" />
            <button class="btn btn-outline-secondary gdrive-path-button" data-target="general-upload-select" type="button">경로 불러오기</button>
          </div>
          <select class="form-select gdrive-path-select d-none" id="general-upload-select" data-bind-input="gdrive_upload"></select>
          <small class="text-muted">불러온 경로 중 원하는 폴더를 골라 업로드 경로로 설정하세요.</small>
        </div>
        <div class="col-md-3">
          <label class="form-label">ChatGPT 토큰</label>
          <input class="form-control" name="chatgpt_token" value="{{ settings.auth.chatgpt_token }}" />
        </div>
        <div class="col-md-3">
          <label class="form-label">rclone 원격 이름 (Google Drive)</label>
          <input class="form-control" name="gdrive_remote" value="{{ settings.auth.gdrive_remote }}" />
          <small class="text-muted">기본값: gdrive</small>
        </div>

        <div class="col-12 d-flex justify-content-between align-items-center">
          <div>
            <span class="badge bg-light text-dark">저장 설정</span>
            <small class="text-muted ms-2">로컬 저장 경로와 드라이브 연동 정보를 관리합니다.</small>
          </div>
          <button class="btn btn-primary">설정 저장</button>
        </div>
      </form>
      <div class="manual-upload mt-4 pt-3 border-top" id="manual-upload">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <h6 class="mb-0">수동 업로드</h6>
          <span class="badge bg-secondary">Google Drive</span>
        </div>
        <div class="row g-3 align-items-start">
          <div class="col-lg-6 col-md-12">
            <label class="form-label">로컬 폴더 (/root/rcbot/downloads)</label>
            <div class="input-group flex-nowrap">
              <select class="form-select" id="local-folder-select">
                <option value="">폴더를 선택하세요</option>
              </select>
              <button class="btn btn-outline-secondary" type="button" id="local-folder-search">파일 불러오기</button>
            </div>
            <small class="text-muted">폴더를 선택한 뒤 불러온 목록에서 업로드할 파일을 체크하세요.</small>
            <div class="file-list mt-2" id="local-file-list">
              <div class="small text-muted" id="local-folder-search-results">폴더를 선택하면 파일 목록을 볼 수 있습니다.</div>
            </div>
          </div>
          <div class="col-lg-3 col-md-6">
            <label class="form-label">Google Drive 폴더</label>
            <select class="form-select gdrive-path-select d-none" id="manual-remote-select">
              <option value="">폴더를 선택하세요</option>
            </select>
            <button class="btn btn-outline-secondary w-100 mt-2 rounded-3 gdrive-path-button" data-target="manual-remote-select" type="button">경로 불러오기</button>
            <small class="text-muted d-block mt-1">rclone에서 불러온 폴더를 선택하세요.</small>
          </div>
          <div class="col-lg-3 col-md-6 d-grid gap-2">
            <label class="form-label">선택 파일 업로드</label>
            <button class="btn btn-dark" type="button" id="manual-upload-button" disabled>업로드</button>
            <small class="text-muted">Drive 경로를 선택한 뒤 업로드하세요.</small>
          </div>
        </div>
        <div class="progress mt-3 d-none" id="manual-upload-progress">
          <div class="progress-bar bg-dark" role="progressbar" style="width: 0%" id="manual-upload-progress-bar"></div>
        </div>
        <div class="small text-muted mt-2" id="manual-upload-status">대기 중</div>
      </div>
    </div>
  </div>
</div>

<script>
  const liveForm = document.getElementById("live-form");
  const liveUrlInput = document.getElementById("live_url");
  const liveStatus = document.getElementById("live-status");
  const liveTimer = document.getElementById("live-timer");
  const livePreviewFrame = document.getElementById("live-preview-frame");
  const livePreviewPlaceholder = document.getElementById("live-preview-placeholder");
  const liveSearchButton = document.getElementById("live-search-button");
  const liveCaptureButton = document.getElementById("live-capture-button");
  const liveExtendButton = document.getElementById("live-extend-button");
  const liveStopButton = document.getElementById("live-stop-button");
  const livePauseButton = liveForm?.querySelector('button[value="일시정지"]');
  const liveAutoStopLabel = document.getElementById("live-auto-stop");
  const LIVE_TIMER_KEY = "yt-helper-live-started-at";
  const LIVE_DEFAULT_DURATION_MS = 10 * 60 * 1000;
  const LIVE_EXTEND_STEP_MS = 10 * 60 * 1000;
  const LIVE_PAUSE_AUTO_STOP_MS = 10 * 60 * 1000;
  let liveTimerId;
  let liveCountdownTimerId;
  let liveCountdownLastTick;
  let liveRemainingMs = LIVE_DEFAULT_DURATION_MS;
  let liveState = "idle";
  let liveAutoStopInFlight = false;
  let livePauseTimeoutId;

  const setLiveStatus = (message, variant = "text-danger") => {
    if (!liveStatus) return;
    liveStatus.className = `form-text ${variant}`;
    liveStatus.textContent = message || "";
  };

  const isLiveUrl = (value) => {
    if (!value) return false;
    const normalized = value.toLowerCase();
    return ["youtube.com/live", "youtu.be", "live.youtube.com"].some((key) => normalized.includes(key));
  };

  const extractYoutubeId = (value) => {
    if (!value) return null;

    const idPattern = /^[a-zA-Z0-9_-]{6,}$/;
    if (idPattern.test(value) && !value.includes("/")) {
      return value;
    }

    try {
      const url = new URL(value);
      const host = url.hostname.replace(/^www\./, "").toLowerCase();

      if (host === "youtu.be") {
        return url.pathname.split("/").filter(Boolean)[0] || null;
      }

      if (host.endsWith("youtube.com")) {
        const byParam = url.searchParams.get("v");
        if (byParam) return byParam;

        const parts = url.pathname.split("/").filter(Boolean);
        if (parts[0] === "live" && parts[1]) return parts[1];
        if (parts[0] === "embed" && parts[1]) return parts[1];
      }
    } catch (error) {
      return null;
    }

    return null;
  };

  const showLivePreview = (embedUrl) => {
    if (!livePreviewFrame || !livePreviewPlaceholder) return;
    livePreviewFrame.src = embedUrl;
    livePreviewFrame.classList.remove("d-none");
    livePreviewPlaceholder.classList.add("d-none");
  };

  const formatElapsed = (ms) => {
    const totalSeconds = Math.max(0, Math.floor(ms / 1000));
    const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
    const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
    const seconds = String(totalSeconds % 60).padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  };

  const formatCountdown = (ms) => {
    const totalSeconds = Math.max(0, Math.floor(ms / 1000));
    const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
    const seconds = String(totalSeconds % 60).padStart(2, "0");
    return `${minutes}:${seconds}`;
  };

  const stopLiveTimer = () => {
    if (liveTimerId) {
      clearInterval(liveTimerId);
    }
    if (liveTimer) {
      liveTimer.textContent = "대기 중";
      liveTimer.classList.remove("text-primary", "fw-semibold");
    }
    liveTimerId = undefined;
  };

  const startLiveTimer = (startedAt) => {
    if (!liveTimer) return;
    const origin = Number(startedAt);
    if (Number.isNaN(origin)) return;
    stopLiveTimer();
    const render = () => {
      const elapsed = Date.now() - origin;
      liveTimer.textContent = `녹화 ${formatElapsed(elapsed)}`;
    };
    render();
    liveTimer.classList.add("text-primary", "fw-semibold");
    liveTimerId = setInterval(render, 1000);
  };

  const resumeLiveTimer = () => {
    const saved = localStorage.getItem(LIVE_TIMER_KEY);
    if (saved) {
      startLiveTimer(Number(saved));
    }
  };

  const renderAutoStopCountdown = () => {
    if (!liveAutoStopLabel) return;
    liveAutoStopLabel.textContent = `녹화 자동 종료 : ${formatCountdown(liveRemainingMs)}`;
  };

  const updateExtendButtonState = () => {
    if (!liveExtendButton) return;
    const canExtend = liveState !== "idle" && liveRemainingMs < 3 * 60 * 1000;
    liveExtendButton.disabled = !canExtend;
  };

  const setStopButtonMode = (mode) => {
    if (!liveStopButton) return;
    if (mode === "restart") {
      liveStopButton.textContent = "재시작";
      liveStopButton.value = "재시작";
      liveStopButton.classList.remove("btn-outline-danger");
      liveStopButton.classList.add("btn-outline-success");
    } else {
      liveStopButton.textContent = "종료";
      liveStopButton.value = "종료";
      liveStopButton.classList.add("btn-outline-danger");
      liveStopButton.classList.remove("btn-outline-success");
    }
  };

  const setLiveState = (nextState) => {
    liveState = nextState;
    if (liveState === "paused") {
      setStopButtonMode("restart");
    } else {
      setStopButtonMode("stop");
    }
    updateExtendButtonState();
  };

  const clearPauseTimeout = () => {
    if (livePauseTimeoutId) clearTimeout(livePauseTimeoutId);
    livePauseTimeoutId = undefined;
  };

  const schedulePauseTimeout = () => {
    clearPauseTimeout();
    livePauseTimeoutId = setTimeout(() => {
      handleAutoStop("일시정지 상태로 10분이 지나 자동 종료합니다.");
    }, LIVE_PAUSE_AUTO_STOP_MS);
  };

  const resetCountdown = () => {
    if (liveCountdownTimerId) clearInterval(liveCountdownTimerId);
    liveCountdownTimerId = undefined;
    liveCountdownLastTick = undefined;
    liveRemainingMs = LIVE_DEFAULT_DURATION_MS;
    renderAutoStopCountdown();
    updateExtendButtonState();
  };

  const startCountdown = () => {
    liveCountdownLastTick = Date.now();
    if (liveCountdownTimerId) return;
    liveCountdownTimerId = setInterval(() => {
      if (liveState !== "recording") {
        liveCountdownLastTick = Date.now();
        return;
      }

      const now = Date.now();
      const delta = now - (liveCountdownLastTick || now);
      liveCountdownLastTick = now;

      liveRemainingMs = Math.max(0, liveRemainingMs - delta);
      renderAutoStopCountdown();
      updateExtendButtonState();

      if (liveRemainingMs <= 0) {
        clearInterval(liveCountdownTimerId);
        liveCountdownTimerId = undefined;
        handleAutoStop("녹화 시간이 만료되어 자동 종료합니다.");
      }
    }, 500);
  };

  const handleAutoStop = async (message) => {
    if (liveAutoStopInFlight) return;
    liveAutoStopInFlight = true;
    setLiveStatus(message, "text-warning");
    await performLiveAction("종료", { silent: true });
    liveAutoStopInFlight = false;
  };

  const handleLiveActionSuccess = (action) => {
    if (action === "녹화 시작") {
      const now = Date.now();
      localStorage.setItem(LIVE_TIMER_KEY, now.toString());
      startLiveTimer(now);
      resetCountdown();
      setLiveState("recording");
      startCountdown();
      clearPauseTimeout();
      return;
    }

    if (action === "종료") {
      localStorage.removeItem(LIVE_TIMER_KEY);
      stopLiveTimer();
      resetCountdown();
      clearPauseTimeout();
      setLiveState("idle");
      return;
    }

    if (action === "일시정지") {
      setLiveState("paused");
      clearPauseTimeout();
      schedulePauseTimeout();
      return;
    }

    if (action === "재시작") {
      setLiveState("recording");
      startCountdown();
      clearPauseTimeout();
    }
  };

  const performLiveAction = async (action, { liveUrl, silent = false } = {}) => {
    if (!action) {
      if (!silent) setLiveStatus("지원하지 않는 요청입니다.");
      return { ok: false };
    }

    const trimmedUrl = liveUrl?.trim?.() || liveUrlInput?.value?.trim() || "";

    if (action === "녹화 시작") {
      if (!trimmedUrl) {
        if (!silent) setLiveStatus("라이브 주소를 입력하세요.");
        return { ok: false };
      }
      if (!isLiveUrl(trimmedUrl)) {
        if (!silent) setLiveStatus("라이브 링크를 넣어주세요. 실시간 스트림 주소를 확인하세요.");
        return { ok: false };
      }
    }

    if (!silent) {
      setLiveStatus("요청을 처리하는 중입니다...", "text-muted");
    }

    try {
      const response = await fetch("{{ url_for('record_live_action') }}", {
        method: "POST",
        headers: { "Content-Type": "application/json", Accept: "application/json" },
        body: JSON.stringify({ action, live_url: trimmedUrl }),
      });

      const payload = await response.json().catch(() => ({}));
      const ok = response.ok && payload.ok;

      if (ok) {
        handleLiveActionSuccess(action);
        if (!silent) setLiveStatus(payload.message || "요청을 완료했습니다.", "text-success");
      } else if (!silent) {
        setLiveStatus(payload.message || "요청 처리 중 오류가 발생했습니다.", "text-danger");
      }

      return { ok, payload };
    } catch (error) {
      if (!silent) setLiveStatus("요청을 전송하지 못했습니다. 네트워크 상태를 확인하세요.", "text-danger");
      return { ok: false, error };
    }
  };

  if (liveForm && liveUrlInput) {
    resumeLiveTimer();
    renderAutoStopCountdown();
    updateExtendButtonState();
    setLiveState("idle");

    liveForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const action = event.submitter?.value;
      await performLiveAction(action, { liveUrl: liveUrlInput.value });
    });
  }

  if (liveSearchButton && liveUrlInput) {
    liveSearchButton.addEventListener("click", () => {
      const liveUrl = liveUrlInput.value.trim();

      if (!liveUrl) {
        setLiveStatus("라이브 주소를 입력하세요.");
        return;
      }

      if (!isLiveUrl(liveUrl)) {
        setLiveStatus("라이브 링크를 넣어주세요. 실시간 스트림 주소를 확인하세요.");
        return;
      }

      const videoId = extractYoutubeId(liveUrl);
      if (!videoId) {
        setLiveStatus("유튜브 링크에서 영상 ID를 찾지 못했습니다.", "text-danger");
        return;
      }

      const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1`;
      showLivePreview(embedUrl);
      setLiveStatus("스트리밍 화면을 불러왔습니다.", "text-success");
    });
  }

  const captureLivePreview = async () => {
    const liveUrl = liveUrlInput?.value?.trim();
    if (!liveUrl) {
      setLiveStatus("라이브 주소를 입력한 뒤 캡처하세요.", "text-danger");
      return;
    }

    if (!isLiveUrl(liveUrl)) {
      setLiveStatus("유튜브 라이브 링크가 맞는지 확인하세요.", "text-danger");
      return;
    }

    setLiveStatus("서버에서 스트리밍을 캡처하는 중입니다...", "text-muted");

    try {
      const response = await fetch("{{ url_for('capture_live_action') }}", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ live_url: liveUrl }),
      });

      const payload = await response.json();
      if (response.ok && payload.ok) {
        setLiveStatus(payload.message || "캡처 완료", "text-success");
      } else {
        setLiveStatus(payload.message || "캡처에 실패했습니다.", "text-danger");
      }
    } catch (error) {
      setLiveStatus("캡처 요청 중 오류가 발생했습니다.", "text-danger");
    }
  };

  if (liveCaptureButton) {
    liveCaptureButton.addEventListener("click", captureLivePreview);
  }

  if (liveExtendButton) {
    liveExtendButton.addEventListener("click", () => {
      if (liveState === "idle") {
        setLiveStatus("녹화 중일 때만 시간을 연장할 수 있습니다.", "text-danger");
        return;
      }

      liveRemainingMs = Math.max(0, liveRemainingMs) + LIVE_EXTEND_STEP_MS;
      liveCountdownLastTick = Date.now();
      startCountdown();
      renderAutoStopCountdown();
      updateExtendButtonState();
      setLiveStatus("녹화 시간을 10분 연장했습니다.", "text-success");
    });
  }

  const downloadForm = document.getElementById("download-form");
  const downloadProgress = document.getElementById("download-progress");
  const progressBar = document.getElementById("download-progress-bar");
  const downloadStatus = document.getElementById("download-status");
  const gdriveButtons = document.querySelectorAll(".gdrive-path-button");
  const gdriveSelects = document.querySelectorAll(".gdrive-path-select");
  const manualUploadButton = document.getElementById("manual-upload-button");
  const manualUploadProgress = document.getElementById("manual-upload-progress");
  const manualUploadProgressBar = document.getElementById("manual-upload-progress-bar");
  const manualUploadStatus = document.getElementById("manual-upload-status");
  const manualRemoteSelect = document.getElementById("manual-remote-select");
  const localFolderSelect = document.getElementById("local-folder-select");
  const localFolderSearchButton = document.getElementById("local-folder-search");
  const localFileList = document.getElementById("local-file-list");
  const localFolderResults = document.getElementById("local-folder-search-results");
  const transcriptFormEl = document.getElementById("transcript-form");
  const summaryFormEl = document.getElementById("summary-form");
  const transcriptProgress = document.getElementById("transcript-progress");
  const summaryProgress = document.getElementById("summary-progress");
  const transcriptProgressBar = document.getElementById("transcript-progress-bar");
  const summaryProgressBar = document.getElementById("summary-progress-bar");
  const transcriptSelect = document.getElementById("transcript-file");
  const summarySelect = document.getElementById("summary-file");
  const transcriptRefreshButton = document.getElementById("transcript-refresh");
  const summaryRefreshButton = document.getElementById("summary-refresh");
  const transcriptStatus = document.getElementById("transcript-status");
  const summaryStatus = document.getElementById("summary-status");
  let cachedGdrivePaths = null;

  const bindSelectsToInputs = () => {
    gdriveSelects.forEach((select) => {
      const inputId = select.dataset.bindInput;
      const targetInput = inputId ? document.getElementById(inputId) : null;
      if (!targetInput) return;
      select.addEventListener("change", () => {
        if (select.value) {
          targetInput.value = select.value;
        }
      });
    });
  };

  const populateGdriveSelects = (paths) => {
    gdriveSelects.forEach((select) => {
      select.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "폴더를 선택하세요";
      select.appendChild(placeholder);

      paths.forEach((path) => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path;
        select.appendChild(option);
      });
    });
  };

  const showTaskProgress = (wrapper, bar) => {
    if (!wrapper || !bar) return;
    wrapper.classList.remove("d-none");
    bar.classList.remove("bg-success", "bg-danger");
    bar.style.width = "15%";
    let current = 15;
    const tick = () => {
      current = Math.min(95, current + Math.random() * 18);
      bar.style.width = `${current}%`;
    };
    return setInterval(tick, 500);
  };

  const finishTaskProgress = (timerId, wrapper, bar, ok) => {
    if (timerId) clearInterval(timerId);
    if (!wrapper || !bar) return;

    bar.style.width = "100%";
    bar.classList.toggle("bg-success", !!ok);
    bar.classList.toggle("bg-danger", !ok);
    setTimeout(() => wrapper.classList.add("d-none"), 1400);
  };

  const setTaskStatus = (el, message, variant = "text-muted") => {
    if (!el) return;
    el.className = `form-text ${variant}`;
    el.textContent = message;
  };

  const handleTranscriptSubmit = async (event) => {
    event.preventDefault();
    const selectedOption = transcriptSelect?.selectedOptions?.[0];
    if (!selectedOption || selectedOption.disabled || !transcriptSelect?.value) {
      setTaskStatus(transcriptStatus, "전사할 파일을 선택하세요.", "text-danger");
      return;
    }

    setTaskStatus(transcriptStatus, "전사 작업을 시작합니다...", "text-muted");
    const timer = showTaskProgress(transcriptProgress, transcriptProgressBar);

    try {
      const response = await fetch("{{ url_for('transcript_action') }}", {
        method: "POST",
        headers: { "Content-Type": "application/json", Accept: "application/json" },
        body: JSON.stringify({ file_name: transcriptSelect.value }),
      });

      const payload = await response.json().catch(() => ({}));
      const ok = response.ok && payload.ok;
      finishTaskProgress(timer, transcriptProgress, transcriptProgressBar, ok);
      setTaskStatus(
        transcriptStatus,
        payload.message || (ok ? "전사가 완료되었습니다." : "전사 작업에 실패했습니다."),
        ok ? "text-success" : "text-danger"
      );
    } catch (error) {
      finishTaskProgress(timer, transcriptProgress, transcriptProgressBar, false);
      setTaskStatus(transcriptStatus, "전사 요청 중 오류가 발생했습니다.", "text-danger");
    }
  };

  const handleSummarySubmit = async (event) => {
    event.preventDefault();
    const selectedOption = summarySelect?.selectedOptions?.[0];
    if (!selectedOption || selectedOption.disabled || !summarySelect?.value) {
      setTaskStatus(summaryStatus, "요약할 전사 파일을 선택하세요.", "text-danger");
      return;
    }

    setTaskStatus(summaryStatus, "요약을 준비합니다...", "text-muted");
    const timer = showTaskProgress(summaryProgress, summaryProgressBar);

    try {
      const response = await fetch("{{ url_for('summary_action') }}", {
        method: "POST",
        headers: { "Content-Type": "application/json", Accept: "application/json" },
        body: JSON.stringify({ file_name: summarySelect.value }),
      });

      const payload = await response.json().catch(() => ({}));
      const ok = response.ok && payload.ok;
      finishTaskProgress(timer, summaryProgress, summaryProgressBar, ok);
      setTaskStatus(
        summaryStatus,
        payload.message || (ok ? "요약을 완료했습니다." : "요약 작업에 실패했습니다."),
        ok ? "text-success" : "text-danger"
      );
    } catch (error) {
      finishTaskProgress(timer, summaryProgress, summaryProgressBar, false);
      setTaskStatus(summaryStatus, "요약 요청 중 오류가 발생했습니다.", "text-danger");
    }
  };

  const setupTaskProgress = () => {
    transcriptFormEl?.addEventListener("submit", handleTranscriptSubmit);
    summaryFormEl?.addEventListener("submit", handleSummarySubmit);
  };

  const renderSourceOptions = (selectEl, sources) => {
    if (!selectEl) return;
    selectEl.innerHTML = "";

    (sources || []).forEach(({ name, files }) => {
      const group = document.createElement("optgroup");
      group.label = name;

      if (files?.length) {
        files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file;
          option.textContent = file;
          group.appendChild(option);
        });
      } else {
        const option = document.createElement("option");
        option.disabled = true;
        option.textContent = "파일이 없습니다";
        group.appendChild(option);
      }

      selectEl.appendChild(group);
    });

    if (!selectEl.childElementCount) {
      const placeholder = document.createElement("option");
      placeholder.disabled = true;
      placeholder.textContent = "목록이 없습니다";
      selectEl.appendChild(placeholder);
    }
  };

  const refreshSourceOptions = async (buttonEl, selectEl, endpoint) => {
    if (!selectEl || !endpoint) return;
    const previousValue = selectEl.value;
    const originalContent = buttonEl?.innerHTML;

    if (buttonEl) {
      buttonEl.disabled = true;
      buttonEl.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
    }

    try {
      const response = await fetch(endpoint);
      const payload = await response.json();
      if (!response.ok || !payload.ok) {
        throw new Error(payload.message || "목록을 불러오지 못했습니다.");
      }

      renderSourceOptions(selectEl, payload.sources || []);
      const matching = Array.from(selectEl.options).find((option) => option.value === previousValue && !option.disabled);
      if (matching) {
        selectEl.value = previousValue;
      }
    } catch (error) {
      alert(error.message || "목록을 새로고침하는 중 문제가 발생했습니다.");
    } finally {
      if (buttonEl) {
        buttonEl.disabled = false;
        buttonEl.innerHTML = originalContent || "업데이트";
      }
    }
  };

  const setupSourceRefreshers = () => {
    if (transcriptRefreshButton && transcriptSelect) {
      transcriptRefreshButton.addEventListener("click", () =>
        refreshSourceOptions(transcriptRefreshButton, transcriptSelect, "{{ url_for('transcript_sources_api') }}")
      );
    }

    if (summaryRefreshButton && summarySelect) {
      summaryRefreshButton.addEventListener("click", () =>
        refreshSourceOptions(summaryRefreshButton, summarySelect, "{{ url_for('summary_sources_api') }}")
      );
    }
  };

  const loadGdrivePaths = async (triggerButton) => {
    if (cachedGdrivePaths) return cachedGdrivePaths;
    const originalText = triggerButton?.textContent;
    if (triggerButton) {
      triggerButton.disabled = true;
      triggerButton.textContent = "불러오는 중...";
    }

    try {
      const response = await fetch("{{ url_for('gdrive_folders') }}");
      const payload = await response.json();
      if (!response.ok || !payload.ok) {
        throw new Error(payload.message || "Google Drive 경로를 불러오지 못했습니다.");
      }
      cachedGdrivePaths = payload.folders || [];
      populateGdriveSelects(cachedGdrivePaths);
      return cachedGdrivePaths;
    } catch (error) {
      alert(error.message || "Google Drive 호출 중 오류가 발생했습니다.");
      return [];
    } finally {
      if (triggerButton) {
        triggerButton.disabled = false;
        triggerButton.textContent = originalText || "경로 불러오기";
      }
    }
  };

  const setupGdriveButtons = () => {
    bindSelectsToInputs();
    gdriveButtons.forEach((button) => {
      const targetId = button.dataset.target;
      const select = targetId ? document.getElementById(targetId) : null;
      if (!select) return;

      button.addEventListener("click", async () => {
        await loadGdrivePaths(button);
        select.classList.remove("d-none");
        select.scrollIntoView({ behavior: "smooth", block: "nearest" });
      });
    });
  };

  const setLocalFolderMessage = (message) => {
    if (localFolderResults) {
      localFolderResults.textContent = message;
    }
  };

  const getSelectedFiles = () => {
    if (!localFileList) return [];
    return Array.from(localFileList.querySelectorAll("input[type='checkbox']:checked")).map((input) => input.value);
  };

  const renderLocalFiles = (files, baseDir) => {
    if (!localFileList) return;
    localFileList.innerHTML = "";

    if (!files || !files.length) {
      const empty = document.createElement("div");
      empty.className = "small text-muted";
      empty.textContent = "파일이 없습니다.";
      localFileList.appendChild(empty);
      updateManualButtonState();
      return;
    }

    const header = document.createElement("div");
    header.className = "small text-muted mb-2";
    header.textContent = `${baseDir || "선택한 경로"}에서 ${files.length}개 파일`;
    localFileList.appendChild(header);

    const list = document.createElement("div");
    list.className = "d-flex flex-column gap-1";

    files.forEach((name, index) => {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "form-check-input me-2";
      checkbox.id = `local-file-${index}`;
      checkbox.value = name;

      const label = document.createElement("label");
      label.className = "form-check-label";
      label.htmlFor = checkbox.id;
      label.textContent = name;

      const wrapper = document.createElement("div");
      wrapper.className = "form-check d-flex align-items-center border bg-white";
      wrapper.appendChild(checkbox);
      wrapper.appendChild(label);

      list.appendChild(wrapper);

      checkbox.addEventListener("change", () => {
        updateManualButtonState();
      });
    });

    localFileList.appendChild(list);
    updateManualButtonState();
  };

  const loadLocalFolders = async () => {
    if (!localFolderSelect) return [];
    try {
      const endpoint = new URL("{{ url_for('local_folders') }}", window.location.origin);

      const response = await fetch(endpoint);
      const payload = await response.json();
      if (!response.ok || !payload.ok) {
        throw new Error(payload.message || "로컬 폴더를 불러오지 못했습니다.");
      }

      const previousValue = localFolderSelect.value;
      localFolderSelect.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "폴더를 선택하세요";
      localFolderSelect.appendChild(placeholder);

      const folders = payload.folders || [];

      folders.forEach((name) => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        localFolderSelect.appendChild(option);
      });

      if (previousValue && folders.includes(previousValue)) {
        localFolderSelect.value = previousValue;
      }
      return folders;
    } catch (error) {
      alert(error.message || "로컬 폴더 목록을 가져오는 중 오류가 발생했습니다.");
      return [];
    }
  };

  const updateManualButtonState = () => {
    if (!manualUploadButton) return;
    const hasFiles = getSelectedFiles().length > 0;
    manualUploadButton.disabled = !(hasFiles && manualRemoteSelect?.value);
  };

  const setupManualUpload = () => {
    if (!manualUploadButton) return;

    const startBar = () => {
      if (!manualUploadProgress || !manualUploadProgressBar) return null;
      manualUploadProgress.classList.remove("d-none");
      manualUploadProgressBar.classList.remove("bg-success", "bg-danger");
      manualUploadProgressBar.style.width = "10%";
      return setInterval(() => {
        const current = parseFloat(manualUploadProgressBar.style.width) || 10;
        const next = Math.min(96, current + Math.random() * 15);
        manualUploadProgressBar.style.width = `${next}%`;
      }, 500);
    };

    const finishBar = (ok) => {
      if (!manualUploadProgress || !manualUploadProgressBar) return;
      manualUploadProgressBar.style.width = "100%";
      manualUploadProgressBar.classList.toggle("bg-success", !!ok);
      manualUploadProgressBar.classList.toggle("bg-danger", !ok);
      setTimeout(() => manualUploadProgress.classList.add("d-none"), 1600);
    };

    const handleUpload = async () => {
      const files = getSelectedFiles();
      if (!localFolderSelect?.value || !manualRemoteSelect?.value || !files.length) {
        manualUploadStatus.textContent = "업로드할 파일과 경로를 모두 선택하세요.";
        return;
      }
      manualUploadButton.disabled = true;
      manualUploadStatus.textContent = "업로드 준비 중...";
      const timer = startBar();

      try {
        const response = await fetch("{{ url_for('manual_files_upload') }}", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            local_path: localFolderSelect.value,
            files,
            remote_path: manualRemoteSelect.value,
          }),
        });

        const payload = await response.json();
        const success = response.ok && payload.ok;
        finishBar(success);
        manualUploadStatus.textContent = payload.message || (success ? "업로드 완료" : "업로드에 실패했습니다.");
      } catch (error) {
        finishBar(false);
        manualUploadStatus.textContent = "업로드 요청 중 오류가 발생했습니다.";
      } finally {
        manualUploadButton.disabled = false;
        if (timer) clearInterval(timer);
      }
    };

    manualUploadButton.addEventListener("click", handleUpload);
    localFolderSelect?.addEventListener("change", () => {
      setLocalFolderMessage("파일을 불러오려면 버튼을 눌러주세요.");
      localFileList && (localFileList.innerHTML = "");
      updateManualButtonState();
    });
    manualRemoteSelect?.addEventListener("change", () => {
      updateManualButtonState();
    });
    localFolderSearchButton?.addEventListener("click", async () => {
      if (!localFolderSelect?.value) {
        setLocalFolderMessage("폴더를 먼저 선택하세요.");
        return;
      }
      setLocalFolderMessage("파일을 불러오는 중입니다...");
      try {
        const endpoint = new URL("{{ url_for('local_files') }}", window.location.origin);
        endpoint.searchParams.set("folder", localFolderSelect.value);
        const response = await fetch(endpoint);
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.message || "파일 목록을 불러오지 못했습니다.");
        }
        renderLocalFiles(payload.files || [], payload.base);
        setLocalFolderMessage(payload.files?.length ? "불러온 파일에서 업로드 대상을 선택하세요." : "파일이 없습니다.");
      } catch (error) {
        setLocalFolderMessage(error.message || "파일 목록을 가져오는 중 오류가 발생했습니다.");
      }
    });

    loadLocalFolders();
    updateManualButtonState();
  };

  if (downloadForm) {
    let timerId;

    const updateProgress = (value, stateClass = "bg-info") => {
      progressBar.style.width = `${value}%`;
      progressBar.className = `progress-bar ${stateClass}`;
    };

    const startProgress = () => {
      downloadProgress.classList.remove("d-none");
      updateProgress(6);
      timerId = setInterval(() => {
        const current = parseFloat(progressBar.style.width) || 0;
        const next = Math.min(current + Math.random() * 12, 92);
        updateProgress(next);
      }, 400);
    };

    const finishProgress = (ok) => {
      clearInterval(timerId);
      updateProgress(100, ok ? "bg-success" : "bg-danger");
    };

    downloadForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const videoUrl = document.getElementById("video_url").value;

      if (!videoUrl) {
        downloadStatus.textContent = "링크를 입력하세요.";
        return;
      }

      startProgress();
      downloadStatus.textContent = "다운로드 중...";

      try {
        const response = await fetch("{{ url_for('download_action') }}", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ video_url: videoUrl }),
        });

        const payload = await response.json();
        const success = response.ok && payload.ok;
        finishProgress(success);
        downloadStatus.textContent = payload.message || (success ? "다운로드 완료" : "다운로드에 실패했습니다.");
      } catch (error) {
        finishProgress(false);
        downloadStatus.textContent = "다운로드 요청 중 오류가 발생했습니다.";
      }
    });
  }

  setupSourceRefreshers();
  setupGdriveButtons();
  setupManualUpload();
  setupTaskProgress();
</script>
{% endblock %}
